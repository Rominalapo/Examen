<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Simplex con Gráfica y Vértices</title>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <style>
    body { font-family: Arial; padding: 20px; background-color: #f9f9f9; }
    input, select { margin: 4px; width: 60px; }
    .bloque { margin-bottom: 15px; }
    table { border-collapse: collapse; margin-top: 20px; }
    td, th { border: 1px solid #aaa; padding: 6px 10px; text-align: center; }
    .pivot { background-color: #ffd700 !important; }
    .mensaje { margin-top: 10px; font-weight: bold; }
  </style>
</head>
<body>
  <h2>Método Simplex Gráfico Interactivo</h2>

  <div class="bloque">
    <label>Tipo de problema:</label>
    <select id="tipo">
      <option value="max">Maximizar</option>
      <option value="min">Minimizar</option>
    </select>
  </div>

  <div class="bloque">
    <label>Función Objetivo Z = </label>
    <input type="number" id="c1" value="3" step="any" />x +
    <input type="number" id="c2" value="5" step="any" />y
  </div>

  <div class="bloque">
    <label>Restricciones (ax + by ≤/≥ c):</label><br />
    <div id="restricciones">
      <div>
        <input type="number" value="2" class="a" step="any" />x +
        <input type="number" value="1" class="b" step="any" />y
        <select class="signo">
          <option value="<=" selected>≤</option>
          <option value=">=">&#8805;</option>
        </select>
        <input type="number" value="8" class="c" step="any" />
      </div>
      <div>
        <input type="number" value="1" class="a" step="any" />x +
        <input type="number" value="2" class="b" step="any" />y
        <select class="signo">
          <option value="<=" selected>≤</option>
          <option value=">=">&#8805;</option>
        </select>
        <input type="number" value="6" class="c" step="any" />
      </div>
    </div>
    <button onclick="agregarRestriccion()">Agregar restricción</button>
  </div>

  <button onclick="resolverGrafico()">Mostrar Gráfica</button>
  <button onclick="resolverSimplex()">Resolver con Simplex</button>

  <div id="grafica" style="width:100%;height:500px;margin-top:20px;"></div>
  <div id="vertices"></div>
  <div id="tablaSimplex"></div>
  <div id="analisis"></div>

  <script>
    function agregarRestriccion() {
      const cont = document.getElementById("restricciones");
      const div = document.createElement("div");
      div.innerHTML = `
        <input type="number" value="0" class="a" step="any" />x +
        <input type="number" value="0" class="b" step="any" />y
        <select class="signo">
          <option value="<=" selected>≤</option>
          <option value=">=">&#8805;</option>
        </select>
        <input type="number" value="0" class="c" step="any" />
      `;
      cont.appendChild(div);
    }

    function generarLineaRestriccion(a, b, c) {
      const xmin = 0, xmax = 20;
      const ymin = 0, ymax = 20;
      let xvals = [];
      let yvals = [];

      if (Math.abs(b) > 1e-10) {
        const y0 = (c - a * xmin) / b;
        const y1 = (c - a * xmax) / b;
        let points = [];

        if (y0 >= ymin - 1e-6 && y0 <= ymax + 1e-6) points.push({ x: xmin, y: y0 });
        if (y1 >= ymin - 1e-6 && y1 <= ymax + 1e-6) points.push({ x: xmax, y: y1 });

        if (Math.abs(a) > 1e-10) {
          const x_at_ymin = (c - b * ymin) / a;
          if (x_at_ymin >= xmin - 1e-6 && x_at_ymin <= xmax + 1e-6) points.push({ x: x_at_ymin, y: ymin });
          const x_at_ymax = (c - b * ymax) / a;
          if (x_at_ymax >= xmin - 1e-6 && x_at_ymax <= xmax + 1e-6) points.push({ x: x_at_ymax, y: ymax });
        }

        points = points.filter(p => p.x >= xmin - 1e-6 && p.x <= xmax + 1e-6 && p.y >= ymin - 1e-6 && p.y <= ymax + 1e-6);
        points.sort((p1, p2) => p1.x - p2.x);

        if (points.length >= 2) {
          xvals = [points[0].x, points[1].x];
          yvals = [points[0].y, points[1].y];
        } else if (points.length === 1) {
          xvals = [points[0].x];
          yvals = [points[0].y];
        }
      } else if (Math.abs(a) > 1e-10) {
        const xconst = c / a;
        if (xconst >= xmin && xconst <= xmax) {
          xvals = [xconst, xconst];
          yvals = [ymin, ymax];
        }
      }
      return { xvals, yvals };
    }

    function resolverGrafico() {
      const c1 = parseFloat(document.getElementById("c1").value);
      const c2 = parseFloat(document.getElementById("c2").value);
      const tipo = document.getElementById("tipo").value;
      const aEls = document.querySelectorAll(".a");
      const bEls = document.querySelectorAll(".b");
      const cEls = document.querySelectorAll(".c");
      const signoEls = document.querySelectorAll(".signo");

      let restricciones = [];
      let trazasRestricciones = [];

      for (let i = 0; i < aEls.length; i++) {
        let a = parseFloat(aEls[i].value);
        let b = parseFloat(bEls[i].value);
        let c = parseFloat(cEls[i].value);
        let signo = signoEls[i].value;
        if (signo === ">=") {
          a = -a; b = -b; c = -c;
        }
        restricciones.push({ a, b, c });

        const { xvals, yvals } = generarLineaRestriccion(a, b, c);
        if (xvals.length === 2 && yvals.length === 2) {
          trazasRestricciones.push({
            x: xvals,
            y: yvals,
            type: 'scatter',
            mode: 'lines',
            name: `R${i + 1}`,
            line: { dash: 'dashdot' }
          });
        }
      }

      const interseccion = (r1, r2) => {
        const det = r1.a * r2.b - r2.a * r1.b;
        if (Math.abs(det) < 1e-10) return null;
        const x = (r1.c * r2.b - r2.c * r1.b) / det;
        const y = (r1.a * r2.c - r2.a * r1.c) / det;
        return { x, y };
      };

      const cumple = (p) => {
        if (p.x < -1e-6 || p.y < -1e-6) return false;
        for (const r of restricciones) {
          if (r.a * p.x + r.b * p.y - r.c > 1e-6) return false;
        }
        return true;
      };

      let vertices = [];

      for (let i = 0; i < restricciones.length; i++) {
        for (let j = i + 1; j < restricciones.length; j++) {
          const p = interseccion(restricciones[i], restricciones[j]);
          if (p && cumple(p)) vertices.push(p);
        }
      }

      for (const r of restricciones) {
        if (Math.abs(r.b) > 1e-6) {
          const y = r.c / r.b;
          if (y >= 0 && cumple({ x: 0, y })) vertices.push({ x: 0, y });
        }
        if (Math.abs(r.a) > 1e-6) {
          const x = r.c / r.a;
          if (x >= 0 && cumple({ x, y: 0 })) vertices.push({ x, y: 0 });
        }
      }

      vertices.push({ x: 0, y: 0 });
      vertices = vertices.filter(cumple);

      vertices = vertices.filter((v, i, arr) =>
        arr.findIndex(p => Math.abs(p.x - v.x) < 1e-5 && Math.abs(p.y - v.y) < 1e-5) === i
      );

      vertices = vertices.map(v => ({ ...v, z: c1 * v.x + c2 * v.y }));
      let optimo = vertices[0];
      for (let v of vertices) {
        if ((tipo === "max" && v.z > optimo.z) || (tipo === "min" && v.z < optimo.z)) {
          optimo = v;
        }
      }

      const centro = vertices.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
      centro.x /= vertices.length;
      centro.y /= vertices.length;

      vertices.sort((p1, p2) => {
        const a1 = Math.atan2(p1.y - centro.y, p1.x - centro.x);
        const a2 = Math.atan2(p2.y - centro.y, p2.x - centro.x);
        return a1 - a2;
      });

      const traceRegion = {
        x: [...vertices.map(v => v.x), vertices[0].x],
        y: [...vertices.map(v => v.y), vertices[0].y],
        fill: 'toself',
        type: 'scatter',
        fillcolor: 'rgba(0,150,255,0.2)',
        line: { color: 'blue' },
        name: 'Región Factible'
      };

      const tracePuntos = {
        x: vertices.map(v => v.x),
        y: vertices.map(v => v.y),
        mode: 'markers+text',
        type: 'scatter',
        name: 'Vértices',
        marker: { color: 'red', size: 8 },
        text: vertices.map(v => `Z=${v.z.toFixed(2)}`),
        textposition: 'top right'
      };

      const traceOptimo = {
        x: [optimo.x],
        y: [optimo.y],
        mode: 'markers+text',
        type: 'scatter',
        name: 'Óptimo',
        marker: { color: 'green', size: 14, symbol: 'diamond' },
        text: [`Óptimo Z=${optimo.z.toFixed(2)}`],
        textposition: 'bottom center'
      };

      Plotly.newPlot('grafica', [...trazasRestricciones, traceRegion, tracePuntos, traceOptimo], {
        title: 'Gráfica de la Región Factible',
        xaxis: { title: 'x', range: [0, 20] },
        yaxis: { title: 'y', range: [0, 20] }
      });

      let html = "<h3>Vértices Evaluados</h3><ul>";
      vertices.forEach(v => {
        const isOpt = (Math.abs(v.x - optimo.x) < 1e-5 && Math.abs(v.y - optimo.y) < 1e-5);
        html += `<li>(${v.x.toFixed(3)}, ${v.y.toFixed(3)}) → Z = ${v.z.toFixed(3)}${isOpt ? " <b>(Óptimo)</b>" : ""}</li>`;
      });
      html += "</ul>";
      document.getElementById("vertices").innerHTML = html;

      // Limpiar tabla y análisis
      document.getElementById("tablaSimplex").innerHTML = "";
      document.getElementById("analisis").innerHTML = "";
    }

    function resolverSimplex() {
      const tipo = document.getElementById("tipo").value;
      const c1 = parseFloat(document.getElementById("c1").value);
      const c2 = parseFloat(document.getElementById("c2").value);

      const aEls = document.querySelectorAll(".a");
      const bEls = document.querySelectorAll(".b");
      const cEls = document.querySelectorAll(".c");
      const signoEls = document.querySelectorAll(".signo");

      // Validar inputs básicos
      if (isNaN(c1) || isNaN(c2)) {
        alert("Ingresa coeficientes válidos para la función objetivo.");
        return;
      }

      // Preparar restricciones en forma ax + by <= c
      let restricciones = [];
      for (let i = 0; i < aEls.length; i++) {
        let a = parseFloat(aEls[i].value);
        let b = parseFloat(bEls[i].value);
        let c = parseFloat(cEls[i].value);
        let signo = signoEls[i].value;
        if (isNaN(a) || isNaN(b) || isNaN(c)) {
          alert(`Restricción ${i + 1} tiene coeficientes no válidos.`);
          return;
        }
        if (signo === ">=") {
          a = -a; b = -b; c = -c;
        }
        restricciones.push({ a, b, c });
      }

      const m = restricciones.length; // número de restricciones
      if (m === 0) {
        alert("Agrega al menos una restricción.");
        return;
      }
      const n = 2 + m; // variables x,y + holgura

      // Construir tabla simplex inicial
      let tabla = [];
      for (let i = 0; i < m; i++) {
        let fila = Array(n + 1).fill(0);
        fila[0] = restricciones[i].a;
        fila[1] = restricciones[i].b;
        fila[2 + i] = 1;
        fila[n] = restricciones[i].c;
        tabla.push(fila);
      }

      let filaZ = Array(n + 1).fill(0);
      filaZ[0] = tipo === "max" ? -c1 : c1;
      filaZ[1] = tipo === "max" ? -c2 : c2;
      filaZ[n] = 0;
      tabla.push(filaZ);

      let base = [];
      for (let i = 0; i < m; i++) base.push(2 + i);

      function imprimirTabla(tabla, base, iteracion, pivoteFila, pivoteCol) {
        const varsNombres = ["x", "y"];
        for (let i = 0; i < m; i++) varsNombres.push("s" + (i + 1));
        let html = `<h3>Iteración ${iteracion}</h3><table><thead><tr><th>Base</th>`;
        for (let j = 0; j < n; j++) html += `<th>${varsNombres[j]}</th>`;
        html += "<th>Solución</th></tr></thead><tbody>";

        for (let i = 0; i < m; i++) {
          html += `<tr><td>${varsNombres[base[i]]}</td>`;
          for (let j = 0; j <= n; j++) {
            let clase = "";
            if (i === pivoteFila && j === pivoteCol) clase = "pivot";
            html += `<td class="${clase}">${tabla[i][j].toFixed(4)}</td>`;
          }
          html += "</tr>";
        }
        // fila Z
        html += `<tr><td>Z</td>`;
        for (let j = 0; j <= n; j++) {
          let clase = "";
          if (m === pivoteFila && j === pivoteCol) clase = "pivot";
          html += `<td class="${clase}">${tabla[m][j].toFixed(4)}</td>`;
        }
        html += "</tr></tbody></table><br/>";
        return html;
      }

      let iter = 0;
      let htmlTotal = "";
      const MAX_ITER = 30;
      let mensajeEstado = "";
      while (iter < MAX_ITER) {
        // Encontrar variable entrada (columna pivote)
        let colPivote = -1;
        let valPivote = tipo === "max" ? 0 : 0;
        for (let j = 0; j < n; j++) {
          let val = tabla[m][j];
          if (tipo === "max") {
            if (val < valPivote) {
              valPivote = val;
              colPivote = j;
            }
          } else {
            if (val > valPivote) {
              valPivote = val;
              colPivote = j;
            }
          }
        }

        if (colPivote === -1) {
          mensajeEstado = "¡Solución óptima encontrada!";
          htmlTotal += imprimirTabla(tabla, base, iter + 1, -1, -1);
          break;
        }

        // Encontrar variable salida (fila pivote)
        let filaPivote = -1;
        let minRatio = Infinity;
        for (let i = 0; i < m; i++) {
          let coef = tabla[i][colPivote];
          if (coef > 1e-10) {
            let ratio = tabla[i][n] / coef;
            if (ratio < minRatio) {
              minRatio = ratio;
              filaPivote = i;
            }
          }
        }

        if (filaPivote === -1) {
          mensajeEstado = "<b>El problema es no acotado.</b>";
          htmlTotal += imprimirTabla(tabla, base, iter + 1, -1, -1);
          break;
        }

        // Mostrar iteración actual con pivote resaltado
        htmlTotal += imprimirTabla(tabla, base, iter + 1, filaPivote, colPivote);

        // Variables que entran y salen
        const varsNombres = ["x", "y"];
        for (let i = 0; i < m; i++) varsNombres.push("s" + (i + 1));
        const varEntra = varsNombres[colPivote];
        const varSale = varsNombres[base[filaPivote]];

        htmlTotal += `<p class="mensaje">Variable que entra: <b>${varEntra}</b>, variable que sale: <b>${varSale}</b></p>`;

        // Pivoteo
        const pivote = tabla[filaPivote][colPivote];
        for (let j = 0; j <= n; j++) {
          tabla[filaPivote][j] /= pivote;
        }
        for (let i = 0; i <= m; i++) {
          if (i !== filaPivote) {
            const factor = tabla[i][colPivote];
            for (let j = 0; j <= n; j++) {
              tabla[i][j] -= factor * tabla[filaPivote][j];
            }
          }
        }
        base[filaPivote] = colPivote;
        iter++;
      }

      if (!mensajeEstado) mensajeEstado = "Límite de iteraciones alcanzado.";

      // Mostrar solución
      let sol = Array(n).fill(0);
      for (let i = 0; i < m; i++) {
        if (base[i] < n) sol[base[i]] = tabla[i][n];
      }
      let zOpt = tabla[m][n];
      if (tipo === "max") zOpt = -zOpt;

      htmlTotal += `<h3>Solución Óptima</h3>
      <p>Z = ${zOpt.toFixed(4)}</p>
      <p>x = ${sol[0].toFixed(4)}, y = ${sol[1].toFixed(4)}</p>`;

      htmlTotal += `<h3>Análisis</h3>
      <p>El método Simplex encontró la solución óptima tras ${iter} iteración(es). 
      Las variables básicas representan las restricciones activas que limitan la solución. 
      El valor de la función objetivo refleja el máximo (o mínimo) alcanzable con las restricciones dadas. 
      Este proceso confirma la consistencia entre el análisis gráfico y algebraico.</p>`;

      htmlTotal += `<p class="mensaje">${mensajeEstado}</p>`;

      document.getElementById("tablaSimplex").innerHTML = htmlTotal;
      document.getElementById("analisis").scrollIntoView({ behavior: "smooth" });
    }
  </script>
</body>
</html>
